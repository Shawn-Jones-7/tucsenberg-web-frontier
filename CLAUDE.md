<!-- OPENSPEC:START -->
# OpenSpec Instructions

These instructions are for AI assistants working in this project.

Always open `@/openspec/AGENTS.md` when the request:
- Mentions planning or proposals (words like proposal, spec, change, plan)
- Introduces new capabilities, breaking changes, architecture shifts, or big performance/security work
- Sounds ambiguous and you need the authoritative spec before coding

Use `@/openspec/AGENTS.md` to learn:
- How to create and apply change proposals
- Spec format and conventions
- Project structure and guidelines

Keep this managed block so 'openspec update' can refresh the instructions.

<!-- OPENSPEC:END -->

# CLAUDE.md

## 0. Global Protocols

All operations must strictly adhere to the following system constraints:

- **Language**: Use **English** when interacting with tools or models; use **Chinese** for user-facing output.
- **Multi-turn Sessions**: When tools/models return a `SESSION_ID` or similar field, record it and **actively evaluate** whether to continue the conversation in subsequent calls. Codex/Gemini may interrupt sessions due to internal tool calls—if the expected response is incomplete, continue the dialogue.
- **Sandbox Security**: Codex/Gemini are **prohibited** from performing file system writes. All code retrieval must **explicitly request** `Unified Diff Patch` in the prompt—no real modifications allowed.
- **Code Sovereignty**: Code generated by external models serves only as a logic reference (Prototype). Final deliverable code **must be refactored** to ensure zero redundancy and enterprise-grade standards.
- **Style Definition**: Code style is **always** positioned as lean, efficient, and redundancy-free. This applies equally to comments and documentation, which must strictly follow the **"only when necessary"** principle.
- **Targeted Changes Only**: Modifications must be scoped precisely to requirements—never impact existing functionality.
- Codex/Gemini interactions are provided as SKILLs—**proactively invoke them**. Both require longer execution times (system default `BASH_DEFAULT_TIMEOUT_MS: 300000`)—wait patiently.
- When parallelizable tasks are detected, execute them concurrently whenever possible. Use `run_in_background` to suspend long-running commands and proceed with the next, achieving parallelism.
- **Mandatory**: Follow all Phases in Section 1. Workflow—no phase may be skipped.
- **Git Workflow**: Before any file write, verify current branch is NOT `main`. If on `main`, create and switch to a feature branch first (`git checkout -b <type>/<description>`). Branch naming: `feat/`, `fix/`, `docs/`, `chore/`, `refactor/`.

---

## 1. Workflow

### Phase 1: Context Retrieval (Auggie Interface)

**Trigger**: Before generating any suggestions or code.

1. **Tool Invocation**: Call `mcp__auggie-mcp__codebase-retrieval`.
2. **Retrieval Strategy**:
   - **Forbidden**: Answering based on assumptions.
   - Use natural language (NL) to construct semantic queries (Where/What/How).
   - **Completeness Check**: Must obtain complete definitions and signatures for relevant classes, functions, and variables. If context is insufficient, trigger recursive retrieval.
3. **Requirement Alignment**: If ambiguity remains after retrieval, **must** output a list of guiding questions to the user until requirement boundaries are clear (no omissions, no redundancy).

### Phase 2: Multi-Model Analysis (Analysis & Strategy)

**Trigger**: After context is ready, before coding begins.

1. **Distribute Input**: Forward the user's **raw requirements** (without preconceptions) to both Codex and Gemini. Note: Both have complete CLI systems, so **minimal context is needed**.
2. **Solution Iteration**:
   - Request multi-perspective solutions from both models.
   - Execute **cross-validation**: Integrate ideas, iterate optimization, perform logical reasoning and complement strengths/weaknesses until a step-by-step implementation plan with no logical gaps is generated.
3. **User Confirmation**: Present the final implementation plan to the user (with appropriate pseudo-code).

### Phase 3: Prototyping

**Trigger**: After implementation plan is confirmed. Route by task type:

- **Route A: Frontend / UI / Styling (Gemini Kernel)**
  - **Limitation**: Context < 32k. Gemini has deficiencies in backend logic understanding—evaluate its responses objectively.
  - **Directive**: Request CSS/React/Vue prototypes. Use this as the final frontend design prototype and visual baseline.
- **Route B: Backend / Logic / Algorithm (Codex Kernel)**
  - **Capability**: Leverage its logical computation and debugging abilities.
  - **Directive**: Request logic implementation prototypes.
- **Universal Constraint**: In all communications with Codex/Gemini, **must explicitly request** `Unified Diff Patch` in the prompt—no real modifications allowed.

### Phase 4: Implementation

**Precondition**: **Proactively invoke** Context7 (`resolve-library-id` → `get-library-docs`) to query official documentation for relevant tech stack (e.g., React, Next.js, TypeScript, Tailwind), ensuring implementation aligns with official best practices and latest version specifications.

**Execution Guidelines**:

1. **Logic Refactoring**: Based on Phase 3 prototypes, remove redundancy and **rewrite** into highly readable, maintainable, enterprise-release-grade code.
2. **Documentation Standard**: Do not generate comments or documentation unless necessary—code should be self-explanatory.
3. **Minimal Scope**: Changes must be limited to requirement scope. **Mandatory review** for whether changes introduce side effects, with targeted corrections.

### Phase 5: Audit & Delivery

1. **Automated Audit**: After changes take effect, **immediately invoke** both Codex and Gemini simultaneously for Code Review, then synthesize and fix.
   - Checklist: Logic correctness, requirement coverage, potential bugs.
2. **Delivery**: Deliver to user after audit passes.

---

## 2. Resource Matrix

This matrix defines **mandatory** resource dispatch strategies per phase. Claude, as the **Orchestrator**, must strictly dispatch external resources according to the current Workflow phase per the following specifications.

| Phase | Functionality | Model / Tool | Output Constraint | Critical Behavior |
|:------|:--------------|:-------------|:------------------|:------------------|
| **1** | Context Retrieval | **Auggie** | Raw Code / Definitions | No grep; recursive until complete |
| **2** | Analysis & Planning | **Codex** + **Gemini** | Step-by-Step Plan | Cross-validate; eliminate logic gaps |
| **3A** | Frontend / UI | **Gemini** | Unified Diff Patch | Context < 32k; ignore backend advice |
| **3B** | Backend / Logic | **Codex** | Unified Diff Patch | sandbox=read-only |
| **4** | Implementation | **Claude (Self)** + **Context7** | Production Code | Proactively query official docs |
| **5** | Audit & QA | **Codex** + **Gemini** | Review Comments | Trigger immediately after changes |

---

## 3. Project

**Stack**: Next.js 16 (App Router, Cache Components) + React 19 + TypeScript 5 + Tailwind CSS 4 + next-intl

**Philosophy**: Adopt latest stable tech stack versions, maximize new features for performance.

**Purpose**: Enterprise website template with i18n (en/zh), SSR/SSG, and enterprise-grade quality gates.

**Structure**:
```
src/
├── app/[locale]/          # App Router pages (async Server Components)
├── components/            # UI components (shadcn/ui based)
├── lib/                   # Utilities, content loaders, services
├── i18n/                  # next-intl config (request.ts, routing.ts)
├── hooks/                 # Custom React hooks
└── types/                 # TypeScript definitions
content/{posts,pages,products}/{locale}/ # MDX content files
messages/[locale]/         # i18n JSON (critical.json + deferred.json)
```

**Node Version**: This project requires Node.js 20.x. Use fnm to switch before running commands:
```bash
eval "$(fnm env)" && fnm use 20
```

**Commands**:
```bash
pnpm dev          # Start dev server (Turbopack)
pnpm build        # Production build
pnpm type-check   # TypeScript validation
pnpm lint         # ESLint check
pnpm test         # Vitest unit tests
```

---

## 4. Hard Constraints

1. **TypeScript strict** — No `any`, prefer `interface`
2. **Server Components first** — Use `"use client"` only for interactivity
3. **i18n required** — All user-facing text must use translation keys
4. **Complexity limits** — Function ≤120 lines, File ≤500 lines

---

## 5. References

Detailed rules in `.claude/rules/`:

- `architecture.md` — Next.js 16 Cache Components, Async APIs
- `coding-standards.md` — Naming conventions, import order
- `quality-gates.md` — Complexity limits, test coverage, Lighthouse
- `security.md` — XSS prevention, input validation, CSP
- `debugging.md` — Systematic troubleshooting workflow
- `threat-modeling.md` — STRIDE analysis
