/**
 * Content Manifest Generator
 *
 * Scans content/{posts,pages,products}/{en,zh}/ directories and generates:
 * 1. reports/content-manifest.json - Content metadata for runtime queries
 * 2. src/lib/mdx-importers.generated.ts - Static import map for RSC rendering
 * 3. src/lib/content-manifest.generated.ts - TypeScript manifest (no runtime fs)
 *
 * Usage: pnpm content:manifest
 */

import fs from 'fs';
import path from 'path';

const CONTENT_DIR = path.join(process.cwd(), 'content');
const MANIFEST_OUTPUT = path.join(
  process.cwd(),
  'reports',
  'content-manifest.json',
);
const IMPORTERS_OUTPUT = path.join(
  process.cwd(),
  'src',
  'lib',
  'mdx-importers.generated.ts',
);
const MANIFEST_TS_OUTPUT = path.join(
  process.cwd(),
  'src',
  'lib',
  'content-manifest.generated.ts',
);

const CONTENT_TYPES = ['posts', 'pages', 'products'] as const;
const LOCALES = ['en', 'zh'] as const;
const VALID_EXTENSIONS = ['.mdx', '.md'];

type ContentType = (typeof CONTENT_TYPES)[number];
type Locale = (typeof LOCALES)[number];

interface ContentEntry {
  type: ContentType;
  locale: Locale;
  slug: string;
  extension: string;
  filePath: string;
  relativePath: string;
}

interface ContentManifest {
  entries: ContentEntry[];
  byKey: Record<string, ContentEntry>;
}

function scanDirectory(
  contentType: ContentType,
  locale: Locale,
): ContentEntry[] {
  const dirPath = path.join(CONTENT_DIR, contentType, locale);
  const entries: ContentEntry[] = [];

  if (!fs.existsSync(dirPath)) {
    return entries;
  }

  const files = fs.readdirSync(dirPath);

  for (const file of files) {
    const ext = path.extname(file);
    if (!VALID_EXTENSIONS.includes(ext)) {
      continue;
    }

    const slug = path.basename(file, ext);
    const filePath = path.join(dirPath, file);
    const relativePath = path.relative(process.cwd(), filePath);

    entries.push({
      type: contentType,
      locale,
      slug,
      extension: ext,
      filePath,
      relativePath,
    });
  }

  return entries;
}

function buildManifestKey(
  type: ContentType,
  locale: Locale,
  slug: string,
): string {
  return `${type}/${locale}/${slug}`;
}

function generateManifest(): ContentManifest {
  const entries: ContentEntry[] = [];

  for (const contentType of CONTENT_TYPES) {
    for (const locale of LOCALES) {
      const typeEntries = scanDirectory(contentType, locale);
      entries.push(...typeEntries);
    }
  }

  const byKey: Record<string, ContentEntry> = {};
  for (const entry of entries) {
    const key = buildManifestKey(entry.type, entry.locale, entry.slug);
    byKey[key] = entry;
  }

  return {
    entries,
    byKey,
  };
}

function ensureOutputDir(outputPath: string): void {
  const outputDir = path.dirname(outputPath);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }
}

function generateImportersCode(entries: ContentEntry[]): string {
  const entriesByType = new Map<ContentType, Map<Locale, ContentEntry[]>>();

  for (const entry of entries) {
    let typeMap = entriesByType.get(entry.type);
    if (typeMap === undefined) {
      typeMap = new Map();
      entriesByType.set(entry.type, typeMap);
    }
    let localeEntries = typeMap.get(entry.locale);
    if (localeEntries === undefined) {
      localeEntries = [];
      typeMap.set(entry.locale, localeEntries);
    }
    localeEntries.push(entry);
  }

  const lines: string[] = [
    '/**',
    ' * AUTO-GENERATED FILE - DO NOT EDIT',
    ' *',
    ' * Generated by: pnpm content:manifest',
    ' *',
    ' * This file provides static import maps for MDX content.',
    ' * To update, add/remove/rename content files and re-run the generator.',
    ' */',
    '',
    "import type { ComponentType } from 'react';",
    '',
    'export interface MDXContentModule {',
    '  default: ComponentType;',
    '  frontmatter?: Record<string, unknown>;',
    '}',
    '',
    'type ContentImporter = () => Promise<MDXContentModule>;',
    '',
  ];

  const typeToExportName: Record<ContentType, string> = {
    posts: 'postImporters',
    pages: 'pageImporters',
    products: 'productImporters',
  };

  for (const contentType of CONTENT_TYPES) {
    const typeMap = entriesByType.get(contentType);
    const exportName = typeToExportName[contentType];

    lines.push(
      `export const ${exportName}: Record<string, Record<string, ContentImporter>> = {`,
    );

    for (const locale of LOCALES) {
      const localeEntries = typeMap?.get(locale) ?? [];
      lines.push(`  ${locale}: {`);

      for (const entry of localeEntries) {
        const importPath = `@content/${contentType}/${locale}/${entry.slug}${entry.extension}`;
        lines.push(`    '${entry.slug}': () => import('${importPath}'),`);
      }

      lines.push('  },');
    }

    lines.push('};');
    lines.push('');
  }

  return lines.join('\n');
}

function generateManifestTsCode(manifest: ContentManifest): string {
  const entriesJson = JSON.stringify(manifest.entries, null, 2);
  const byKeyJson = JSON.stringify(manifest.byKey, null, 2);

  return `/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 *
 * Generated by: pnpm content:manifest
 *
 * This file provides statically bundled content manifest data.
 * No runtime fs dependency - works in dev and production builds.
 */

import type { ContentType, Locale } from '@/types/content';

export interface ContentEntry {
  type: ContentType;
  locale: Locale;
  slug: string;
  extension: string;
  filePath: string;
  relativePath: string;
}

export interface ContentManifest {
  entries: ContentEntry[];
  byKey: Record<string, ContentEntry>;
}

export const CONTENT_MANIFEST: ContentManifest = {
  entries: ${entriesJson},
  byKey: ${byKeyJson},
} as const;
`;
}

function main(): void {
  console.log('Generating content manifest and import map...');

  const manifest = generateManifest();

  // Output 1: JSON manifest for runtime queries
  ensureOutputDir(MANIFEST_OUTPUT);
  fs.writeFileSync(MANIFEST_OUTPUT, JSON.stringify(manifest, null, 2));

  // Output 2: TypeScript import map for RSC rendering
  ensureOutputDir(IMPORTERS_OUTPUT);
  const importersCode = generateImportersCode(manifest.entries);
  fs.writeFileSync(IMPORTERS_OUTPUT, importersCode);

  // Output 3: TypeScript manifest for static import (no runtime fs)
  ensureOutputDir(MANIFEST_TS_OUTPUT);
  const manifestTsCode = generateManifestTsCode(manifest);
  fs.writeFileSync(MANIFEST_TS_OUTPUT, manifestTsCode);

  console.log(`Generated manifest with ${manifest.entries.length} entries`);
  console.log(`Output 1: ${MANIFEST_OUTPUT}`);
  console.log(`Output 2: ${IMPORTERS_OUTPUT}`);
  console.log(`Output 3: ${MANIFEST_TS_OUTPUT}`);

  // Summary by type
  const summary: Record<string, number> = {};
  for (const entry of manifest.entries) {
    const key = `${entry.type}/${entry.locale}`;
    summary[key] = (summary[key] ?? 0) + 1;
  }

  console.log('\nSummary:');
  for (const [key, count] of Object.entries(summary)) {
    console.log(`  ${key}: ${count} files`);
  }
}

main();
